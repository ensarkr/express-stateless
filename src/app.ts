import express, { Response, Request, NextFunction } from "express";
import { createJWT, verifyJWT } from "./functions/jwt.js";
import { setCookieResponse } from "./functions/cookie.js";
import dotenv from "dotenv";
import cors from "cors";
import { createDoubleCSRF } from "./functions/csrf.js";
import {
  verifyDoubleSignedSubmitGuest_MW,
  verifyDoubleSignedSubmitUser_MW,
} from "./middleware/csrf.js";
import { userAuthorization_MW, validateJWT_MW } from "./middleware/jwt.js";
dotenv.config();

const app = express();
const port = 3000;

// * accept request from frontend of the site
// * cors function sets response headers like Access-Control-Allow-
// * credentials = true to tell browser to allow js to see response
// * and stops process immediately if the requester domain is not allowed
app.use(cors({ origin: "http://localhost:5173", credentials: true }));

// * json() is parses json's in request bodies automatically
app.use(express.json());

// * 2 hour
const CSRFExpirationSecond = 60 * 60 * 2;
// * 1 week
const JWTExpirationSecond = 60 * 60 * 24 * 7;

export type user = {
  id: number;
  name: string;
  email: string;
  hashed_password: string;
  salt: string;
  role: "user" | "admin";
};

// * random objects which is generated by my other project here is a link: https://ensarkr.github.io/random-objects-react/
const users: user[] = [
  {
    id: 0,
    name: "Daniele Mariah",
    email: "lorayne@imperturbable.dk",
    hashed_password: "password",
    salt: "speed",
    role: "user",
  },
  {
    id: 1,
    name: "Phillis Micky",
    email: "kaseyalphonsineramona@maintenance.es",
    hashed_password: "password",
    salt: "bishop",
    role: "admin",
  },
];

// * JWT verified so res.local.jwt should work as expected
app.post("/api/getCSRF", validateJWT_MW, (req: Request, res: Response) => {
  console.log("getCSRF", "request");

  // * X-CSRF-ORIGIN set in forms
  if (req.headers["x-csrf-origin"] === undefined) {
    res.status(401).end();
    return;
  }

  switch (req.headers["x-csrf-origin"]) {
    case "guest": {
      console.log("getCSRF", "guest");

      const {
        CSRFToken: CSRFTokenGuest,
        hashedCSRFToken: hashedCSRFTokenGuest,
      } = createDoubleCSRF({
        type: "ENV",
      });
      // * set csrf token as cookie
      // * return hashed csrf in json
      setCookieResponse(
        res,
        "csrf_token_guest",
        CSRFTokenGuest,
        `SameSite=strict; HttpOnly; Secure; Max-Age=${CSRFExpirationSecond}`
      );
      res.json({
        hashedCSRFTokenGuest,
      });
      res.status(200);
      console.log("getCSRF", "guest", "success");

      res.end();
      return;
    }

    case "user": {
      console.log("getCSRF", "user");

      if (res.locals.jwt) {
        const JWTToken = res.locals.jwt.token as string;
        const {
          CSRFToken: CSRFTokenUser,
          hashedCSRFToken: hashedCSRFTokenUser,
        } = createDoubleCSRF({
          type: "JWT",
          JWT: JWTToken,
        });
        // * set csrf token as cookie
        // * return hashed csrf in json
        setCookieResponse(
          res,
          "csrf_token_user",
          CSRFTokenUser,
          `SameSite=strict; HttpOnly; Secure; Max-Age=${CSRFExpirationSecond}`
        );
        res.json({
          hashedCSRFTokenUser,
        });
        console.log("getCSRF", "user", "success");

        res.status(200).end();
        return;
      }

      console.log("getCSRF", "user", "no JWT token");
      res.status(400).json({ msg: "no JWT token" }).end();
      return;
    }

    default:
      break;
  }
  res.status(400).end();
});

// * login part is guest accessible
// * which means csrf types must be guest
// * on the frontend necessary headers must be correct
app.post("/api/login", verifyDoubleSignedSubmitGuest_MW, (req, res) => {
  console.log("login", "success", "name: " + users[req.body.userId].name);
  setCookieResponse(
    res,
    "jwt_token",
    createJWT(users[req.body.userId], JWTExpirationSecond),
    `SameSite=strict; Secure; Path=/; Max-Age=${JWTExpirationSecond}`
  );
  res.status(200).end();
});

// * logout part is user accessible
// * which means csrf types must be user
// * on the frontend necessary headers must be correct

// * logouts works even if jwt is tampered
// * but jwt is correct and csrf tokens are wrong it does not logout
app.post(
  "/api/logout",
  userAuthorization_MW,
  verifyDoubleSignedSubmitUser_MW,
  (req: Request, res: Response, next: NextFunction) => {
    console.log(
      "logout",
      "success",
      "name: " + res.locals.jwt && res.locals.jwt.payload
        ? (res.locals.jwt.payload as user).name
        : "unknown"
    );

    if (res.locals.jwt) {
      setCookieResponse(res, "jwt_token", "null", "Max-Age=0; Path=/");
    }
    res.locals.jwt = undefined;
    res.status(200).end();
    return;
  }
);

// * getContent part is user accessible
// * which means csrf types must be user
// * on the frontend necessary headers must be correct

// * getContent must have valid JWT therefore it does not proceeds i JWT is tampered or non-existent
// * it return content based on role in JWT
app.get(
  "/api/getContent",
  userAuthorization_MW,
  verifyDoubleSignedSubmitUser_MW,
  (req, res) => {
    const user = res.locals.jwt.payload as user;

    console.log(
      "getContent",
      "success",
      "name: " + user.name,
      "role: " + user.role
    );

    if (user.role === "user") {
      res.status(200).json({ userContent: "user content" }).end();
      return;
    }

    if (user.role === "admin") {
      res
        .status(200)
        .json({
          userContent: "user content",
          adminContent: "super confidential content",
        })
        .end();
      return;
    }

    console.log("getContent", "failed", "name: " + user.name, "no role");
    res.status(400).json({ msg: "no role" }).end();
    return;
  }
);

app.listen(port, () => {
  console.log(`Express stateless backend server listening on port ${port}`);
});
